import java.util.Scanner;//for reader object
import java.util.Arrays;// for array functions
import java.util.List;// for list object
import java.util.ArrayList;//for dynamic arrays
import java.util.Collections;//for sort

public class Main {
    public static void main(String[] args) {

//reading object
        Scanner scn = new Scanner(System.in);

//data types
        int a = 10; 
        long b = 1000L; //l not compulsory, optional, compulsory if b = 1000_1000L;
        double c = 232.6;
        float d = 10.3f;// f compulsory
        byte e = 120;
        char m = '*';
        boolean bo = false;// or true
Use var, the compiler assumes datatype, once assumed cannot change it to another data type values
        var m = 100;
        var li = new int[10];
        var lil = new ArrayList<Integer>();
        final var x = 100;
//typecasting from higher to lower. Lower to higher is automatic c = a;
        int y = (int)c;

//static array object definition
        int[] n = new int[5];
        String[] na = new String[5];

        int[] nums = new int[5];
        String[] strs = {"a", "b", "c"};

//reading array values.
        System.out.println("\nreading values");
        for (int i = 0; i < 5; i++) {
            n[i] = scn.nextInt();
        }

        System.out.println("\nprinting the length");
        System.out.println(n.length);//lenght of an array

//Array methods available in java.util.Arrays
        System.out.println("\ndemonstrating toString function");
        String arr = Arrays.toString(n);//to print array in the form it is
        System.out.println(arr);

        System.out.println("\ndemonstrating sort function");
        Arrays.sort(n);//sorting ascending
        System.out.println(Arrays.toString(n));

        System.out.println("\ndemonstrating binarySearch function");
        int idx = Arrays.binarySearch(n, 5);//binarySearch
        System.out.println(idx);

        System.out.println("\ndemonstrating copyOf function");
        int[] nar = Arrays.copyOf(n, 2);
        System.out.println(Arrays.toString(nar));

        System.out.println("\ndemonstrating fill function");
        Arrays.fill(nums, 7);
        System.out.println(Arrays.toString(nums));

        System.out.println("\ndemonstrating asList function");
        List<String> ars = Arrays.asList(strs);// String[] strs = {"a", "b", "c"};
        System.out.println(ars);
        System.out.println(strs);
        System.out.println(Arrays.equals(n, nums));



//dynamic arrays
        ArrayList<Integer> lst = new ArrayList<>();
        ArrayList<String> str = new ArrayList<>(100);//mentioning capacity to increase optimisation
        ArrayList<String> quick = new ArrayList<>(List.of("a","b","c"));

        System.out.println(lst.size());
        lst.add(80);lst.add(20);//append to end

        System.out.println("\n0th element: "+lst.get(0));//get method to access index

        lst.set(0,453);System.out.println(lst);//set method to set value to index pos

        lst.add(0,1000);System.out.println("insert at 0"+lst);//to insert to first pos
        Collections.sort(lst);System.out.println(lst);//collection sort function to sort array
        lst.sort(null);System.out.println(lst);//another way to sort.
        lst.remove(0);System.out.println(lst);//remove method to remove element.

    }
}
String pools in java
In java when a string is declared, java checks if the string with the same value as to be declared exist. If such exists, then the new string points to the same memory location.
The == operator only checks if the reference pointer is the same.
String s1 = "Cat";
String s2 = "Cat";              // Reuses s1's address from the Pool
String s3 = new String("Cat");  // Forces a new object in Heap
System.out.println(s1 == s2);       // true (Same memory address)
System.out.println(s1 == s3);       // false (Different addresses)
System.out.println(s1.equals(s3));  // true (Same content)

Wrapper classes in java
Autoboxing & Unboxing
Modern Java automatically converts between them, but it comes at a slight performance cost.
•	Autoboxing: int to Integer
o	Integer x = 10; (Compiler actually does: Integer.valueOf(10))
•	Unboxing: Integer to int
o	int y = x; (Compiler actually does: x.intValue())

ALWAYS use .equals() to compare Integer or String objects. Never rely on ==.
Convert primitive array to dynamic array
ArrayList<Integer> list = new ArrayList<>(); 
for (int i : arr) {
 list.add(i); // Auto-boxing happens here (int becomes Integer) }






String functions
Returns Boolean
Str.equals(str2);
Str.equalsIgnoreCase(str2);
Str.isEmpty();
Str.contains(str2);
Str.startsWith(string);

Returns number.
Str.length();
Str.chartAt(0);
Str.indexOf(str);
Str.lastIndexOf(str);

Returns altered string
Str.replace(old,new);//can be string or char
Str.toLowerCase()
Str.toUpperCase()
Str.trim()
Str.strip(“-”)
Str.substring(begin,end);//end  is optional
Str.repeat(6)
Str.toCharArray();
String.join(delimiter, itemslist)
String.valueof(data)

Regex in java.
Theres a format of string called regex.
To represent “\n” in regex, it is represented a “\\n” . as “\” is a special character in regex. And to represent \n you need to say \ is a string here so \\.

demonstration of string operations

import java.util.Arrays;
import java.util.List;

public class Main{

    public static void main(String[] args) {
        System.out.println("========== PART 1: STRING (IMMUTABLE) ==========");
        demonstrateStringMethods();

        System.out.println("\n========== PART 2: STRINGBUILDER (MUTABLE) ==========");
        demonstrateStringBuilderMethods();

        System.out.println("\n========== PART 3: PERFORMANCE (CONCATENATION) ==========");
        demonstratePerformance();
    }

    // ---------------------------------------------------------
    // PART 1: String Class Methods
    // ---------------------------------------------------------
    public static void demonstrateStringMethods() {
        // 1. Creation
        String str1 = "Hello World";            // String Pool
        String str2 = new String("Hello World"); // Heap (Explicit new object)

        // 2. Inspection
        System.out.println("1. Length: " + str1.length());          // 11
        System.out.println("2. Char at index 1: " + str1.charAt(1)); // 'e'
        System.out.println("3. Is Empty? " + "".isEmpty());         // true
        System.out.println("4. Is Blank? " + "   ".isBlank());      // true (Java 11+)

        // 3. Comparison
        // NEVER use == for strings! It checks memory address.
        System.out.println("5. Equals: " + str1.equals(str2));           // true
        System.out.println("6. Ignore Case: " + "java".equalsIgnoreCase("JAVA")); // true
        System.out.println("7. CompareTo: " + "A".compareTo("B"));       // -1 (A is before B)

        // 4. Searching
        String sentence = "The quick brown fox";
        System.out.println("8. Contains 'quick'? " + sentence.contains("quick")); // true
        System.out.println("9. Starts with 'The'? " + sentence.startsWith("The")); // true
        System.out.println("10. Index of 'o': " + sentence.indexOf("o"));        // 12 (First occurrence)
        System.out.println("11. Last Index of 'o': " + sentence.lastIndexOf("o")); // 17

        // 5. Modification (REMEMBER: Strings return a NEW string)
        String messy = "   Java Programming   ";
        System.out.println("12. Trimmed: '" + messy.trim() + "'");
        System.out.println("13. Substring (5-end): " + messy.substring(5)); // "ava Programming   "
        System.out.println("14. Replace: " + messy.replace("Java", "Python"));
        System.out.println("15. UpperCase: " + messy.toUpperCase());

        // 6. Splitting & Joining
        String csv = "Apple,Banana,Cherry";
        String[] fruits = csv.split(",");
        System.out.println("16. Split Array: " + Arrays.toString(fruits));

        String joined = String.join(" | ", "One", "Two", "Three");
        System.out.println("17. Joined: " + joined);

        // 7. Type Conversion
        int number = 100;
        String numStr = String.valueOf(number); // Converts int to "100"
        char[] charArray = "Hi".toCharArray();
        System.out.println("18. Char Array: " + Arrays.toString(charArray));
    }

    // ---------------------------------------------------------
    // PART 2: StringBuilder Class Methods
    // ---------------------------------------------------------
    public static void demonstrateStringBuilderMethods() {
        // 1. Creation
        StringBuilder sb = new StringBuilder("Hello");

        // 2. Appending (Adding to the end) - Efficient!
        sb.append(" World");
        sb.append(2024); // Can append numbers directly
        System.out.println("1. After Append: " + sb); // Hello World2024

        // 3. Insertion (Adding in the middle)
        sb.insert(5, ","); // Insert comma at index 5
        System.out.println("2. After Insert: " + sb); // Hello, World2024

        // 4. Replacement
        // Replace index 7 to 12 (exclusive) with "Java"
        sb.replace(7, 12, "Java");
        System.out.println("3. After Replace: " + sb); // Hello, Java2024

        // 5. Deletion
        sb.delete(11, 15); // Removes "2024"
        System.out.println("4. After Delete: " + sb); // Hello, Java

        // 6. Reversal (Very common interview trick)
        sb.reverse();
        System.out.println("5. After Reverse: " + sb); // avaJ ,olleH
        sb.reverse(); // Flip it back

        // 7. Capacity Management
        // Internal array size before resizing is needed
        System.out.println("6. Current Capacity: " + sb.capacity());
        sb.ensureCapacity(100); // Pre-allocate memory to avoid resizing

        // 8. Convert back to String
        String finalResult = sb.toString();
        System.out.println("7. Final String: " + finalResult);
    }

    // ---------------------------------------------------------
    // PART 3: Performance Check
    // ---------------------------------------------------------
    public static void demonstratePerformance() {
        // Scenario: Combining words in a loop

        // BAD WAY: String Concatenation (+)
        // Creates a new String object in EVERY iteration. O(N^2) complexity.
        long start = System.nanoTime();
        String s = "";
        for (int i = 0; i < 1000; i++) {
            s += "a";
        }
        long end = System.nanoTime();
        System.out.println("String (+) Time: " + (end - start) + " ns");

        // GOOD WAY: StringBuilder
        // Modifies the same internal array. O(N) complexity.
        start = System.nanoTime();
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < 1000; i++) {
            sb.append("a");
        }
        end = System.nanoTime();
        System.out.println("StringBuilder Time: " + (end - start) + " ns");

        System.out.println("(Notice StringBuilder is significantly faster!)");
    }
}
